<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Solar System: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Solar System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Todo List </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="classBillboard.html#a575f7ad12659b9866f1acbd8aaa1cd2a">Billboard::create_glow_texture</a>  (int resolution, int inner_radius, int outer_radius, vec3 color)</dt>
<dd><a class="anchor" id="_todo000001"></a>Setup the texture for the sun billboard by filling <code>img</code> with color values.<ul>
<li>Draw an opaque (alpha == 1) circle with an <code>inner_radius</code> pixel radius in its middle</li>
<li>Outside that circle the texture should become more and more transparent (alpha &lt; 1) to mimic a nice glow effect</li>
<li>Make sure that your texture is fully transparent (alpha == 0) at <code>outer_radius</code> to avoid seeing visible edges</li>
<li>Experiment with the color (set in <code>Solar_Viewer::initialize()</code>) and with how fast you change the transparency until the effect satisfies you  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classBillboard.html#a4367c3bd2d00e367890d610a486088dc">Billboard::update_angles</a>  (const vec3 &amp;billboard_to_eye)</dt>
<dd><a class="anchor" id="_todo000002"></a>update <code>angle_x_</code> and <code>angle_y_</code> of the billboard.<ul>
<li>Make sure that the vector <code>billboard_to_eye</code> is always perpendicular to the billboard's plane</li>
<li>The two angles are related to the polar and azimuthal angle of a sphere</li>
<li><a href="http://dynref.engr.illinois.edu/rvs.html">http://dynref.engr.illinois.edu/rvs.html</a> shows a nice interactive demo and how to convert cartesian coordinates to spherical ones, but have in mind, that OpenGL uses another convention for x,y,z directions than in this example</li>
<li>The function <code>atan2(...)</code> is already defined.</li>
<li>Both should be stored in degree.</li>
<li>There is an offset between the spherical angles and the needed angles. Hint: It helps to set the look_at to the sun (key 1) and print <code>angle_x_</code> and <code>angle_y_</code> to find the right offset by pressing the right, left, up, down keys. The angles should start by 0 and the <code>x_angle_</code> should increase/decrease by pressing right/left by 10 degree (<code>y_angle_</code> analogously by pressing top/down)  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classMoon.html#a756838b46e9a1a15a9fd10757ce97750">Moon::update</a>  () override</dt>
<dd><a class="anchor" id="_todo000008"></a>Update moon's <code>model_matrix_</code> and position (<code>position_</code>). The moon is a bit special, it must rotate around its <code>parent_planet_</code>. Be careful with the translation-rotation-order since rotation matrices always rotate around the current origin.  </dd>
<dt>Member <a class="el" href="classSolar__viewer.html#ac2538a377d30c06a086baf47054835dc">Solar_viewer::draw_scene</a>  (mat4 &amp;projection, mat4 &amp;view)</dt>
<dd><a class="anchor" id="_todo000006"></a>Provide the correct input and draw order for all your objects.<ol type="1">
<li>Add the <code>stars_</code> object to the scene. It is also just a sphere, but drawn from inside. </li>
</ol>
</dd>
<dt>Member <a class="el" href="classSolar__viewer.html#a667e9e5641e37aa706d867d0b68960ec">Solar_viewer::keyboard</a>  (int key, int scancode, int action, int mods) override</dt>
<dd><a class="anchor" id="_todo000003"></a>Implement the ability to change the viewer's distance to the celestial body.<ul>
<li>key 9 should increase and key 0 should decrease the <code>dist_factor_</code></li>
<li>make sure that <code>2.5 &lt; dist_factor_ &lt; 20.0</code> Note: the mouse wheel also activates zooming, if you finish this task.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classSolar__viewer.html#a809131f92ec461e3dea0d23b2831a87b">Solar_viewer::render</a>  () override</dt>
<dd><a class="anchor" id="_todo000005"></a>(optional) Implement stereo rendering.<ol type="1">
<li>Calculate parameters for the left and right eye.</li>
<li>Use <code>mat4::frustum(...)</code> to construct your two projection matrices.</li>
<li>Translate the <code>view</code> matrix to get one for the left and one for the right eye.</li>
</ol>
<ol type="1">
<li><p class="startli">Render two images, one for the left and one for the right eye using <code>draw_scene(...)</code>;.</p><ul>
<li>For <code>view_mode_ == STEREO_ANAGLYPH</code>, look up <code>glColorMask</code> and use it to enable filtering of red/cyan. Setting the rendering to greyscale (by pressing <code>g</code>) will show the effect best.</li>
<li>In view_mode_ == STEREO_SPLIT, you can use <code>glViewport</code> to render the left-eye image on the left (or upper) screen half and the right-eye image on the right (or lower) screen half.</li>
<li>Do not forget to reset viewport and color mask.</li>
</ul>
<p class="startli"><a class="anchor" id="_todo000004"></a>Implement a kind of navigation through the solar system.</p>
</li>
</ol>
<ul>
<li>Allow rotation of the camera. <code>camera_rotation_</code> holds the current camera rotation and is updated when certain keys are pressed (see <code>Solar_viewer::keyboard(...)</code>). <code>dist_factor_</code> is the number of radii from the center of the planet to the camera.</li>
<li>Don't modify the view matrix directly but instead the input of <code>mat4::look_at(...)</code></li>
<li>At the beginning, the camera should be translated in positive z-direction from the planet's center.</li>
<li>The camera should always face the planet's center. The rotation is meant to be around the planet'center not around the camera's center.</li>
<li>If one of the keys <code>1</code> to <code>8</code> is pressed, the camera should face the respective celestial body (compare <code>Solar_viewer::keyboard(...)</code>). <code>look_at_</code> is updated in this case and stores a pointer to the current looked at planet.</li>
<li>To support changing distance to the body see <code>Solar_viewer::keyboard(...)</code> Hint: To understand what effect is desired, it helps to watch the solution videos.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classSpace__Object.html#a3d26e41580a303854b9bc49bad8c0409">Space_Object::create_rings</a>  (float inner_radius, float outer_radius, int resolution, std::string texfile)</dt>
<dd><a class="anchor" id="_todo000009"></a>(optional) Define the saturn ring mesh.<ul>
<li>Fill the vectors defined above. Therefore, find a way to define a ring by triangles.</li>
<li><code>inner_radius_</code> and <code>outer_radius_</code> define the size of the ring.</li>
<li><code>resolution_</code> should determine how many vertices build the outer and inner boundary. So, if you decrease <code>resolution_</code> to 3 for example, the ring should look like a triangle with a hole in the middle.</li>
<li><code>textures/saturn_rings.png</code> is the texture we use for the ring. Think about how you have to define the texcoords <code>u_coords</code> and <code>v_coords</code> to get the desired effect. </li>
</ul>
</dd>
<dt>Member <a class="el" href="classSpace__Object.html#a814f807190b23859ed3e41d800facc55">Space_Object::update</a>  ()</dt>
<dd><a class="anchor" id="_todo000007"></a>Update <code>model_matrix_</code> and position (<code>position_</code>) for each object.<ol type="1">
<li>Combine translation and scaling matrices to get a result like in screenshots/planet_system_initial.png assuming:<ul>
<li>sun at origin</li>
<li>all objects scaled by radius</li>
<li>all objects translated by <code>distance</code> in x direction</li>
</ul>
</li>
<li>Now use y-axis-rotation matrices in the right places to allow rotation around the object's axis (angle_self) and sun (angle_parent)</li>
<li>You can also support a tilt angle if you like (<code>angle_tilt</code>) rotations</li>
<li>Update the object's position using your constructed model matrix Hints:<ul>
<li>See glmath.h/cpp for an overview about implemented matrices.</li>
<li>Order is important! </li>
</ul>
</li>
</ol>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
