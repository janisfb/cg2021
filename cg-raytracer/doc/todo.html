<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ray Tracer: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ray Tracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Todo List </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="classMesh.html#a4e9bedfc415b7135c9587f63535fcb6d">Mesh::compute_normals</a>  ()</dt>
<dd><a class="anchor" id="_todo000001"></a> In some scenes (e.g the office scene) some objects have to be flat shaded (e.g. the desk) while other objects should be Phong shaded to appear realistic (e.g. chairs). We provide code to compute triangle normals. You have to implement the following:<ul>
<li>Compute vertex normals by averaging the normals of their incident triangles.</li>
<li>Store the vertex normals in the <a class="el" href="structMesh_1_1Vertex.html#adf43225146648954d9196e4b6fa47379" title="vertex normal">Vertex::normal</a> member variable.</li>
<li>Weigh the normals by their triangles' angles.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classMesh.html#a3d2d7a99cdfbe128688afe125aa6a88e">Mesh::intersect_bounding_box</a>  (const Ray &amp;ray) const</dt>
<dd><a class="anchor" id="_todo000002"></a> Intersect the ray <code>_ray</code> with the axis-aligned bounding box of the mesh. Note that the minimum and maximum point of the bounding box are stored in the member variables <code>bb_min_</code> and <code>bb_max_</code>. Return whether the ray intersects the bounding box. </dd>
<dt>Member <a class="el" href="classMesh.html#a772e5577c999a4d897dcdd899145309f">Mesh::intersect_triangle</a>  (const <a class="el" href="structMesh_1_1Triangle.html" title="a triangle is specified by three indices and a normal">Triangle</a> &amp;triangle, const Ray &amp;ray, vec3 &amp;intersection_point, vec3 &amp;intersection_normal, vec3 &amp;intersection_diffuse, double &amp;intersection_distance) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000003"></a> Intersect ray with triangle:</p><ul>
<li>store intersection point in <code>intersection_point</code></li>
<li>store ray parameter in <code>intersection_distance</code></li>
<li>store normal at intersection point in <code>intersection_normal</code>.</li>
<li>Depending on the member variable <code>draw_mode_</code>, use either the triangle normal (<code><a class="el" href="structMesh_1_1Triangle.html#a697c3d7e2f4a316e7b486e048efff56d" title="triangle normal">Triangle::normal</a></code>) or interpolate the vertex normals (<code><a class="el" href="structMesh_1_1Vertex.html#adf43225146648954d9196e4b6fa47379" title="vertex normal">Vertex::normal</a></code>).</li>
<li>return <code>true</code> if there is an intersection with t &gt; 1e-5 (avoid "shadow acne")</li>
</ul>
<p class="enddd"><a class="anchor" id="_todo000004"></a> (optional) Support textured triangles:</p><ul>
<li><code>hasTexture_</code> indicates if the mesh is textured.</li>
<li>Acces the three u and v texture coordinates stored in <code>u_coordinates</code> resp. <code>v_coordinates</code> via the triangles iuv indices.</li>
<li>Interpolate the uv-coordinates using your barycentric coordinates to get the intersection point's uv.</li>
<li>Convert the relative uv coordinates (from 0 to 1) to absolute pixel coordinates (from 0 to width/height - 1 of <code>texture_</code>)</li>
<li>Store the resulting texture color in <code>intersection_diffuse</code></li>
<li>You will notice that there will be shadows on the sky mesh in the pokemon scene. Use <code>material.shadowable</code> in the <code>lighting(...)</code> function to prevent it from being shadowed. (<code>material.shadowable</code> is already set to false for the sky mesh and true for all other meshes, so you don't have to set it by yourself)  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classPlane.html#a8c1635ae7b8966288bd339025895cd02">Plane::intersect</a>  (const Ray &amp;_ray, vec3 &amp;intersection_point, vec3 &amp;intersection_normal, vec3 &amp;intersection_diffuse, double &amp;intersection_distance) const</dt>
<dd><a class="anchor" id="_todo000005"></a><ul>
<li>compute the intersection of the plane with <code>ray</code></li>
<li>if ray and plane are parallel there is no intersection</li>
<li>otherwise compute intersection data and store it in <code>intersection_point</code>, <code>intersection_normal</code>, and <code>intersection_t</code>.</li>
<li>return whether there is an intersection for t&gt;1e-5 (avoids "shadow acne").  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classRaytracer.html#a138a2707b619df9c26c8ca206f01db17">Raytracer::compute_image</a>  ()</dt>
<dd><a class="anchor" id="_todo000006"></a> (optional) Implement supersampling to avoid aliasing artifacts:<ul>
<li>Instead of casting just one, you cast n*n rays per pixel and store the average of the traced color values.</li>
<li>Start with 2x2 rays per pixel and check the result with the cube scene.</li>
<li>Try to generalize this to support arbitrary n*n supersampling</li>
<li>To cast this many rays will slow down your image computation. To avoid this, implement adaptive supersampling:<ul>
<li>Supersampling is just needed if neighboring pixels have a noticable difference in their color values</li>
<li>Start with one ray per pixel and store the result in a temporary <code>Image</code> variable</li>
<li>Now, iterate a second time over your image and compare the color values of the each pixel with those of its neighbors' pixels</li>
<li>If this difference is higher than a certain threshold, you apply 4x4 supersampling (SSAA16) for this pixel</li>
<li>Experiment with the rings scene to find a good threshold Hints:</li>
</ul>
</li>
<li>Some image viewers will blur your images by default to avoid aliasing if you zoom in, open your images with an image manipulation tool instead.</li>
<li>It may help to visualize the x and y coordinates of your subrays on a sheet of paper</li>
<li>Try to avoid sqrt computations like in norm when you want to compute a color difference, use normSq instead  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classRaytracer.html#a2838018a6467ed11f65b82d04adccbc5">Raytracer::lighting</a>  (const vec3 &amp;point, const vec3 &amp;normal, const vec3 &amp;view, const Material &amp;material)</dt>
<dd><a class="anchor" id="_todo000008"></a> Compute the Phong lighting:<ul>
<li>start with global ambient contribution</li>
<li>for each light source (stored in vector <code>lights_</code>) add diffuse and specular contribution</li>
<li>only add diffuse and specular light if object is not in shadow </li>
</ul>
</dd>
<dt>Member <a class="el" href="classRaytracer.html#a5a8336d4925562d9f7f69f5333fa79f5">Raytracer::trace</a>  (const Ray &amp;ray, int depth)</dt>
<dd><a class="anchor" id="_todo000007"></a> Compute reflections by recursive ray tracing:<ul>
<li>check whether <code>object</code> is reflective by checking its <code>material.mirror</code></li>
<li>check recursion depth</li>
<li>generate reflected ray, compute its color contribution, and mix it with the color computed by local Phong lighthing (use <code>material.mirror</code> as weight)</li>
<li>check whether your recursive algorithm reflects the ray <code>max_depth_</code> times </li>
</ul>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
